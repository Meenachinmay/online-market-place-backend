// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBalance = `-- name: AddBalance :one
UPDATE wallets SET soda_balance = soda_balance + $1 WHERE user_id = $2 RETURNING user_id, soda_points, soda_balance
`

type AddBalanceParams struct {
	Amount int64  `json:"amount"`
	UserID string `json:"user_id"`
}

func (q *Queries) AddBalance(ctx context.Context, arg AddBalanceParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, addBalance, arg.Amount, arg.UserID)
	var i Wallet
	err := row.Scan(&i.UserID, &i.SodaPoints, &i.SodaBalance)
	return i, err
}

const addPoints = `-- name: AddPoints :one
UPDATE wallets SET soda_points = soda_points + $1 WHERE user_id = $2 RETURNING user_id, soda_points, soda_balance
`

type AddPointsParams struct {
	Amount int64  `json:"amount"`
	UserID string `json:"user_id"`
}

func (q *Queries) AddPoints(ctx context.Context, arg AddPointsParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, addPoints, arg.Amount, arg.UserID)
	var i Wallet
	err := row.Scan(&i.UserID, &i.SodaPoints, &i.SodaBalance)
	return i, err
}

const convertPointsToBalance = `-- name: ConvertPointsToBalance :one
UPDATE wallets 
SET soda_points = soda_points - $1,
    soda_balance = soda_balance + $2
WHERE user_id = $3 AND soda_points >= $1
RETURNING user_id, soda_points, soda_balance
`

type ConvertPointsToBalanceParams struct {
	PointsDeducted int64  `json:"points_deducted"`
	BalanceAdded   int64  `json:"balance_added"`
	UserID         string `json:"user_id"`
}

func (q *Queries) ConvertPointsToBalance(ctx context.Context, arg ConvertPointsToBalanceParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, convertPointsToBalance, arg.PointsDeducted, arg.BalanceAdded, arg.UserID)
	var i Wallet
	err := row.Scan(&i.UserID, &i.SodaPoints, &i.SodaBalance)
	return i, err
}

const countOrdersByBuyer = `-- name: CountOrdersByBuyer :one
SELECT COUNT(*) FROM orders WHERE buyer_id = $1
`

func (q *Queries) CountOrdersByBuyer(ctx context.Context, buyerID string) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByBuyer, buyerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByBuyerAndProduct = `-- name: CountOrdersByBuyerAndProduct :one
SELECT COUNT(*) FROM orders WHERE buyer_id = $1 AND product_id = $2
`

type CountOrdersByBuyerAndProductParams struct {
	BuyerID   string `json:"buyer_id"`
	ProductID string `json:"product_id"`
}

func (q *Queries) CountOrdersByBuyerAndProduct(ctx context.Context, arg CountOrdersByBuyerAndProductParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByBuyerAndProduct, arg.BuyerID, arg.ProductID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBlog = `-- name: CreateBlog :one
INSERT INTO blogs (id, author_id, content, product_id) VALUES ($1, $2, $3, $4) RETURNING id, author_id, content, product_id
`

type CreateBlogParams struct {
	ID        string `json:"id"`
	AuthorID  string `json:"author_id"`
	Content   string `json:"content"`
	ProductID string `json:"product_id"`
}

func (q *Queries) CreateBlog(ctx context.Context, arg CreateBlogParams) (Blog, error) {
	row := q.db.QueryRow(ctx, createBlog,
		arg.ID,
		arg.AuthorID,
		arg.Content,
		arg.ProductID,
	)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Content,
		&i.ProductID,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (id, buyer_id, product_id, blog_id, amount, status, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, buyer_id, product_id, blog_id, amount, status, created_at
`

type CreateOrderParams struct {
	ID        string             `json:"id"`
	BuyerID   string             `json:"buyer_id"`
	ProductID string             `json:"product_id"`
	BlogID    string             `json:"blog_id"`
	Amount    int64              `json:"amount"`
	Status    string             `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.BuyerID,
		arg.ProductID,
		arg.BlogID,
		arg.Amount,
		arg.Status,
		arg.CreatedAt,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.BuyerID,
		&i.ProductID,
		&i.BlogID,
		&i.Amount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (id, name, description, price, buyer_reward_points, author_reward_points) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, description, price, buyer_reward_points, author_reward_points
`

type CreateProductParams struct {
	ID                 string `json:"id"`
	Name               string `json:"name"`
	Description        string `json:"description"`
	Price              int64  `json:"price"`
	BuyerRewardPoints  int32  `json:"buyer_reward_points"`
	AuthorRewardPoints int32  `json:"author_reward_points"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.BuyerRewardPoints,
		arg.AuthorRewardPoints,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.BuyerRewardPoints,
		&i.AuthorRewardPoints,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (id, user_id, type, amount, related_order_id) VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, type, amount, related_order_id, created_at
`

type CreateTransactionParams struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	Type           string      `json:"type"`
	Amount         int64       `json:"amount"`
	RelatedOrderID pgtype.Text `json:"related_order_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.ID,
		arg.UserID,
		arg.Type,
		arg.Amount,
		arg.RelatedOrderID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Amount,
		&i.RelatedOrderID,
		&i.CreatedAt,
	)
	return i, err
}

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets (user_id, soda_points, soda_balance) VALUES ($1, 0, 0) ON CONFLICT (user_id) DO NOTHING RETURNING user_id, soda_points, soda_balance
`

func (q *Queries) CreateWallet(ctx context.Context, userID string) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWallet, userID)
	var i Wallet
	err := row.Scan(&i.UserID, &i.SodaPoints, &i.SodaBalance)
	return i, err
}

const getBlog = `-- name: GetBlog :one
SELECT id, author_id, content, product_id FROM blogs WHERE id = $1
`

func (q *Queries) GetBlog(ctx context.Context, id string) (Blog, error) {
	row := q.db.QueryRow(ctx, getBlog, id)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Content,
		&i.ProductID,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, name, description, price, buyer_reward_points, author_reward_points FROM products WHERE id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id string) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.BuyerRewardPoints,
		&i.AuthorRewardPoints,
	)
	return i, err
}

const getWallet = `-- name: GetWallet :one
SELECT user_id, soda_points, soda_balance FROM wallets WHERE user_id = $1
`

func (q *Queries) GetWallet(ctx context.Context, userID string) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWallet, userID)
	var i Wallet
	err := row.Scan(&i.UserID, &i.SodaPoints, &i.SodaBalance)
	return i, err
}

const listBlogs = `-- name: ListBlogs :many
SELECT id, author_id, content, product_id FROM blogs
`

func (q *Queries) ListBlogs(ctx context.Context) ([]Blog, error) {
	rows, err := q.db.Query(ctx, listBlogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blog
	for rows.Next() {
		var i Blog
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Content,
			&i.ProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, name, description, price, buyer_reward_points, author_reward_points FROM products
`

func (q *Queries) ListProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.BuyerRewardPoints,
			&i.AuthorRewardPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
